# セキュリティと権限管理

Minocでは、セキュリティファーストの設計原則に基づいて、全てのツール実行に対して厳格な権限管理と承認システムを実装しています。

## セキュリティアーキテクチャ

### 主要コンポーネント
- [PermissionManager](mdc:core/permission/permission_manager.ts) - 権限管理
- [SecurityManager](mdc:core/permission/security_manager.ts) - セキュリティポリシー管理
- [ApprovalManager](mdc:cli/ui/approval.ts) - ユーザー承認UI

### セキュリティレベル

1. **厳格（strict）** - 全ての危険な操作に承認が必要
2. **通常（normal）** - 標準的なセキュリティレベル
3. **寛容（permissive）** - 一部の安全な操作は自動承認

## ツールのセキュリティ分類

### 安全なツール（dangerous: false）
```typescript
export class ReadFileTool extends BaseTool {
  override readonly dangerous = false;
  override readonly requiresApproval = false;
  // ファイル読み込みは基本的に安全
}
```

### 危険なツール（dangerous: true）
```typescript
export class WriteToFileTool extends BaseTool {
  override readonly dangerous = true;
  override readonly requiresApproval = true;
  // ファイル書き込みは危険な操作
}
```

### 超危険なツール（要承認）
```typescript
export class ExecuteCommandTool extends BaseTool {
  override readonly dangerous = true;
  override readonly requiresApproval = true;
  // コマンド実行は常に承認が必要
}
```

## 権限管理フロー

### 1. 権限チェック
```typescript
const permissionResult = await this.toolExecutor.checkPermission(toolCall);
if (!permissionResult.allowed) {
  console.log(`❌ ツール実行が拒否されました: ${permissionResult.reason}`);
  return;
}
```

### 2. 承認プロセス
```typescript
if (permissionResult.requiresApproval) {
  const approval = await this.approvalManager.requestApproval(toolCall, permissionResult);
  
  // ユーザーの選択に基づく処理
  switch (approval.choice) {
    case 'allow_once': // 今回だけ許可
    case 'allow_always': // 永続的に許可
    case 'deny': // 今回拒否
    case 'deny_always': // 永続的に拒否
  }
}
```

### 3. 権限設定の永続化
```typescript
// 永続許可
await permissionManager.addToPermanentlyAllowed(toolCall.toolName);

// 永続拒否
await permissionManager.addToAutoReject(toolCall.toolName);
```

## ブロックリスト機能

### 危険なコマンドの自動ブロック
```typescript
const blockedCommands = [
  'rm -rf',        // ファイル全削除
  'del /s',        // Windows ファイル削除
  'format',        // ディスクフォーマット
  'sudo rm',       // 管理者権限でのファイル削除
  'chmod 777',     // 権限を全開放
  // ...その他危険なコマンド
];
```

### カスタマイズ可能なブロックリスト
```toml
# security.toml
blockedCommands = [
  "rm -rf",
  "del /s", 
  "format",
  "sudo",
  "your-custom-blocked-command"
]

permissionLevel = "strict"
```

## 承認UIパターン

### インタラクティブな承認
```
🔧 ツール呼び出し: execute_command
⚠️  危険な操作です: シェルコマンドの実行

実行予定のコマンド:
> npm install express

このツールの実行を許可しますか？
1. 今回だけ許可 (o)
2. 永続的に許可 (a) 
3. 拒否 (n)
4. 永続的に拒否 (d)

選択してください [o/a/n/d]: 
```

### セキュリティ警告の表示
```typescript
console.log('⚠️  危険な操作です: ファイルシステムの変更');
console.log('🔍 セキュリティチェック: コマンドにブロックリストの項目が含まれています');
console.log('🛡️  安全性確認: この操作を本当に実行しますか？');
```

## セキュリティのベストプラクティス

### 入力値の検証
```typescript
// パスのサニタイゼーション
const safePath = path.resolve(path.normalize(userInput));
if (!safePath.startsWith(allowedDirectory)) {
  throw new Error('許可されていないディレクトリへのアクセスです');
}

// コマンドインジェクション対策
const sanitizedCommand = command.replace(/[;&|`$(){}[\]]/g, '');
```

### ファイルアクセス制御
```typescript
// 読み込み権限チェック
const stat = await Deno.stat(filePath);
if (!stat.isFile) {
  return this.error('ファイルではありません');
}

// 書き込み権限チェック
try {
  await Deno.writeTextFile(filePath, content);
} catch (error) {
  if (error instanceof Deno.errors.PermissionDenied) {
    return this.error('ファイルへの書き込み権限がありません');
  }
}
```

### 環境変数の安全な取り扱い
```typescript
// 機密情報を含む可能性のある環境変数をフィルタリング
const safeEnvironment = Object.fromEntries(
  Object.entries(Deno.env.toObject()).filter(([key]) => 
    !key.toLowerCase().includes('key') && 
    !key.toLowerCase().includes('token') &&
    !key.toLowerCase().includes('secret')
  )
);
```

## 履歴とログ

### セキュリティイベントの記録
```typescript
await this.historyRecorder.recordSecurityEvent(sessionId, {
  event: 'permission_denied',
  toolName: toolCall.toolName,
  reason: permissionResult.reason,
  timestamp: new Date().toISOString(),
});
```

### 監査ログ
全てのツール実行とセキュリティイベントは履歴として記録され、後から監査可能です。
description:
globs:
alwaysApply: false
---
