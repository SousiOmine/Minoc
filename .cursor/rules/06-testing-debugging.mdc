# ãƒ†ã‚¹ãƒˆã¨ãƒ‡ãƒãƒƒã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

Minocã§ã¯ã€ä¿¡é ¼æ€§ã®é«˜ã„ã‚³ãƒ¼ãƒ‰ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã®ãƒ†ã‚¹ãƒˆã¨ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å‘½åè¦ç´„
- å˜ä½“ãƒ†ã‚¹ãƒˆ: `{module_name}_test.ts`
- çµ±åˆãƒ†ã‚¹ãƒˆ: `{feature_name}_integration_test.ts`
- ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ: `{workflow_name}_e2e_test.ts`

### ç¾åœ¨ã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
- [main_test.ts](mdc:main_test.ts) - ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆ

## Denoãƒ†ã‚¹ãƒˆã®ä½¿ç”¨

### åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆæ§‹é€ 
```typescript
import { assertEquals, assertRejects } from '@std/assert';
import { describe, it } from '@std/testing/bdd';

describe('ToolExecutor', () => {
  it('should execute safe tools without approval', async () => {
    // ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯
    assertEquals(result.success, true);
  });

  it('should require approval for dangerous tools', async () => {
    // å±é™ºãªãƒ„ãƒ¼ãƒ«ã®ãƒ†ã‚¹ãƒˆ
    await assertRejects(
      () => toolExecutor.executeTool(dangerousTool),
      Error,
      'Approval required'
    );
  });
});
```

### ãƒ„ãƒ¼ãƒ«ãƒ†ã‚¹ãƒˆã®ãƒ‘ã‚¿ãƒ¼ãƒ³
```typescript
describe('ReadFileTool', () => {
  let tool: ReadFileTool;
  let tempFile: string;

  beforeEach(async () => {
    tool = new ReadFileTool();
    tempFile = await Deno.makeTempFile();
    await Deno.writeTextFile(tempFile, 'test content');
  });

  afterEach(async () => {
    await Deno.remove(tempFile);
  });

  it('should read file successfully', async () => {
    const result = await tool.execute({ path: tempFile });
    assertEquals(result.success, true);
    assertEquals(result.data?.content, 'test content');
  });

  it('should handle missing files', async () => {
    const result = await tool.execute({ path: 'nonexistent.txt' });
    assertEquals(result.success, false);
    assertEquals(result.error?.includes('ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'), true);
  });
});
```

## ãƒ¢ãƒƒã‚¯ã¨ã‚¹ã‚¿ãƒ–

### LLMã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ãƒ¢ãƒƒã‚¯
```typescript
class MockOpenAIClient {
  async generateResponse(prompt: string): Promise<string> {
    return 'mocked response';
  }
}

describe('MinocApp with mocked LLM', () => {
  let app: MinocApp;
  
  beforeEach(() => {
    app = new MinocApp();
    // ãƒ¢ãƒƒã‚¯ã‚’æ³¨å…¥
    app.setOpenAIClient(new MockOpenAIClient());
  });
});
```

### ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¢ãƒƒã‚¯
```typescript
// ä¸€æ™‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã®ãƒ†ã‚¹ãƒˆ
const tempDir = await Deno.makeTempDir();
const testContext: ToolExecutionContext = {
  workingDirectory: tempDir,
  environment: {},
  sessionId: 'test-session',
  timestamp: new Date(),
};
```

## ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½

### ãƒ‡ãƒãƒƒã‚°è¨­å®š
```toml
# debug.toml
verboseLogging = true
logApiCalls = true
logToolExecutions = true
measurePerformance = true
```

### ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®è¨­å®š
```typescript
// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
const settings: AppSettings = {
  logLevel: 'DEBUG', // DEBUG, INFO, WARN, ERROR
  debug: true,
  // ...
};
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬
```typescript
const startTime = performance.now();
// å‡¦ç†å®Ÿè¡Œ
const endTime = performance.now();
console.log(`ğŸ•’ å‡¦ç†æ™‚é–“: ${endTime - startTime}ms`);
```

## ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®ãƒ†ã‚¹ãƒˆ

### ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ†ã‚¹ãƒˆ
```typescript
it('should handle permission errors gracefully', async () => {
  // æ¨©é™ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹
  const restrictedFile = '/root/secret.txt';
  const result = await tool.execute({ path: restrictedFile });
  
  assertEquals(result.success, false);
  assertEquals(result.error?.includes('æ¨©é™'), true);
});
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
```typescript
describe('Security Tests', () => {
  it('should block dangerous commands', async () => {
    const dangerousCommand = 'rm -rf /';
    const result = await commandTool.execute({ command: dangerousCommand });
    
    assertEquals(result.success, false);
    assertEquals(result.error?.includes('ãƒ–ãƒ­ãƒƒã‚¯ãƒªã‚¹ãƒˆ'), true);
  });

  it('should sanitize file paths', async () => {
    const maliciousPath = '../../../etc/passwd';
    const result = await fileTool.execute({ path: maliciousPath });
    
    assertEquals(result.success, false);
    assertEquals(result.error?.includes('ä¸æ­£ãªãƒ‘ã‚¹'), true);
  });
});
```

## çµ±åˆãƒ†ã‚¹ãƒˆ

### è¨­å®šç®¡ç†ã®çµ±åˆãƒ†ã‚¹ãƒˆ
```typescript
describe('Config Integration', () => {
  let tempConfigDir: string;
  let configManager: ConfigManager;

  beforeEach(async () => {
    tempConfigDir = await Deno.makeTempDir();
    configManager = new ConfigManager(tempConfigDir);
  });

  it('should migrate from JSON to TOML', async () => {
    // JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
    const jsonConfig = { defaultModel: 'gpt-4' };
    await Deno.writeTextFile(
      join(tempConfigDir, 'settings.json'),
      JSON.stringify(jsonConfig)
    );

    // ç§»è¡Œã‚’å®Ÿè¡Œ
    await configManager.migrateFromJson();

    // TOMLãƒ•ã‚¡ã‚¤ãƒ«ãŒä½œæˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
    const tomlExists = await exists(join(tempConfigDir, 'settings.toml'));
    assertEquals(tomlExists, true);
  });
});
```

## ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

### ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
```bash
# å…¨ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
deno task test

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’å®Ÿè¡Œ
deno test main_test.ts --allow-read --allow-write

# ãƒ†ã‚¹ãƒˆã‚’ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œ
deno test --watch --allow-read --allow-write

# ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆä»˜ãã§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
deno test --coverage=coverage --allow-read --allow-write
deno coverage coverage
```

### CI/CDã§ã®ãƒ†ã‚¹ãƒˆ
```bash
# GitHub Actionsã§ã®è¨­å®šä¾‹
- name: Run tests
  run: |
    deno task test
    deno task lint
    deno task fmt --check
```

## ãƒ‡ãƒãƒƒã‚°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ãƒ­ã‚°å‡ºåŠ›ã®çµ±ä¸€
```typescript
// ãƒ‡ãƒãƒƒã‚°æƒ…å ±
console.log('ğŸ› [DEBUG]', 'ãƒ‡ãƒãƒƒã‚°æƒ…å ±', { variable });

// æƒ…å ±
console.log('â„¹ï¸  [INFO]', 'æƒ…å ±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸');

// è­¦å‘Š
console.warn('âš ï¸  [WARN]', 'è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸');

// ã‚¨ãƒ©ãƒ¼
console.error('âŒ [ERROR]', 'ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸', error);
```

### ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã®ä¿æŒ
```typescript
try {
  await riskyOperation();
} catch (error) {
  // å…ƒã®ã‚¨ãƒ©ãƒ¼ã‚’ä¿æŒ
  throw new Error(`æ“ä½œå¤±æ•—: ${error instanceof Error ? error.message : String(error)}`, {
    cause: error
  });
}
```
description:
globs:
alwaysApply: false
---
