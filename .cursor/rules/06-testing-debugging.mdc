# テストとデバッグガイドライン

Minocでは、信頼性の高いコードを維持するためのテストとデバッグ機能を提供しています。

## テスト戦略

### テストファイルの命名規約
- 単体テスト: `{module_name}_test.ts`
- 統合テスト: `{feature_name}_integration_test.ts`
- エンドツーエンドテスト: `{workflow_name}_e2e_test.ts`

### 現在のテストファイル
- [main_test.ts](mdc:main_test.ts) - メインアプリケーションのテスト

## Denoテストの使用

### 基本的なテスト構造
```typescript
import { assertEquals, assertRejects } from '@std/assert';
import { describe, it } from '@std/testing/bdd';

describe('ToolExecutor', () => {
  it('should execute safe tools without approval', async () => {
    // テストロジック
    assertEquals(result.success, true);
  });

  it('should require approval for dangerous tools', async () => {
    // 危険なツールのテスト
    await assertRejects(
      () => toolExecutor.executeTool(dangerousTool),
      Error,
      'Approval required'
    );
  });
});
```

### ツールテストのパターン
```typescript
describe('ReadFileTool', () => {
  let tool: ReadFileTool;
  let tempFile: string;

  beforeEach(async () => {
    tool = new ReadFileTool();
    tempFile = await Deno.makeTempFile();
    await Deno.writeTextFile(tempFile, 'test content');
  });

  afterEach(async () => {
    await Deno.remove(tempFile);
  });

  it('should read file successfully', async () => {
    const result = await tool.execute({ path: tempFile });
    assertEquals(result.success, true);
    assertEquals(result.data?.content, 'test content');
  });

  it('should handle missing files', async () => {
    const result = await tool.execute({ path: 'nonexistent.txt' });
    assertEquals(result.success, false);
    assertEquals(result.error?.includes('ファイルが見つかりません'), true);
  });
});
```

## モックとスタブ

### LLMクライアントのモック
```typescript
class MockOpenAIClient {
  async generateResponse(prompt: string): Promise<string> {
    return 'mocked response';
  }
}

describe('MinocApp with mocked LLM', () => {
  let app: MinocApp;
  
  beforeEach(() => {
    app = new MinocApp();
    // モックを注入
    app.setOpenAIClient(new MockOpenAIClient());
  });
});
```

### ファイルシステムのモック
```typescript
// 一時ディレクトリでのテスト
const tempDir = await Deno.makeTempDir();
const testContext: ToolExecutionContext = {
  workingDirectory: tempDir,
  environment: {},
  sessionId: 'test-session',
  timestamp: new Date(),
};
```

## デバッグ機能

### デバッグ設定
```toml
# debug.toml
verboseLogging = true
logApiCalls = true
logToolExecutions = true
measurePerformance = true
```

### ログレベルの設定
```typescript
// アプリケーション設定
const settings: AppSettings = {
  logLevel: 'DEBUG', // DEBUG, INFO, WARN, ERROR
  debug: true,
  // ...
};
```

### パフォーマンス計測
```typescript
const startTime = performance.now();
// 処理実行
const endTime = performance.now();
console.log(`🕒 処理時間: ${endTime - startTime}ms`);
```

## エラー処理のテスト

### 例外ハンドリングのテスト
```typescript
it('should handle permission errors gracefully', async () => {
  // 権限エラーを発生させる
  const restrictedFile = '/root/secret.txt';
  const result = await tool.execute({ path: restrictedFile });
  
  assertEquals(result.success, false);
  assertEquals(result.error?.includes('権限'), true);
});
```

### セキュリティテスト
```typescript
describe('Security Tests', () => {
  it('should block dangerous commands', async () => {
    const dangerousCommand = 'rm -rf /';
    const result = await commandTool.execute({ command: dangerousCommand });
    
    assertEquals(result.success, false);
    assertEquals(result.error?.includes('ブロックリスト'), true);
  });

  it('should sanitize file paths', async () => {
    const maliciousPath = '../../../etc/passwd';
    const result = await fileTool.execute({ path: maliciousPath });
    
    assertEquals(result.success, false);
    assertEquals(result.error?.includes('不正なパス'), true);
  });
});
```

## 統合テスト

### 設定管理の統合テスト
```typescript
describe('Config Integration', () => {
  let tempConfigDir: string;
  let configManager: ConfigManager;

  beforeEach(async () => {
    tempConfigDir = await Deno.makeTempDir();
    configManager = new ConfigManager(tempConfigDir);
  });

  it('should migrate from JSON to TOML', async () => {
    // JSONファイルを作成
    const jsonConfig = { defaultModel: 'gpt-4' };
    await Deno.writeTextFile(
      join(tempConfigDir, 'settings.json'),
      JSON.stringify(jsonConfig)
    );

    // 移行を実行
    await configManager.migrateFromJson();

    // TOMLファイルが作成されていることを確認
    const tomlExists = await exists(join(tempConfigDir, 'settings.toml'));
    assertEquals(tomlExists, true);
  });
});
```

## テスト実行

### コマンドラインでのテスト実行
```bash
# 全テストを実行
deno task test

# 特定のテストファイルを実行
deno test main_test.ts --allow-read --allow-write

# テストをウォッチモードで実行
deno test --watch --allow-read --allow-write

# カバレッジレポート付きでテスト実行
deno test --coverage=coverage --allow-read --allow-write
deno coverage coverage
```

### CI/CDでのテスト
```bash
# GitHub Actionsでの設定例
- name: Run tests
  run: |
    deno task test
    deno task lint
    deno task fmt --check
```

## デバッグのベストプラクティス

### ログ出力の統一
```typescript
// デバッグ情報
console.log('🐛 [DEBUG]', 'デバッグ情報', { variable });

// 情報
console.log('ℹ️  [INFO]', '情報メッセージ');

// 警告
console.warn('⚠️  [WARN]', '警告メッセージ');

// エラー
console.error('❌ [ERROR]', 'エラーメッセージ', error);
```

### スタックトレースの保持
```typescript
try {
  await riskyOperation();
} catch (error) {
  // 元のエラーを保持
  throw new Error(`操作失敗: ${error instanceof Error ? error.message : String(error)}`, {
    cause: error
  });
}
```
description:
globs:
alwaysApply: false
---
